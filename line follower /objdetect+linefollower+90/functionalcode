#include <Arduino.h>
#include "CytronMotorDriver.h"
// this does everything except for snow detection!
// =================== Forward declarations / FSM ===================
enum State {
  FORWARD,
  STOP1_AFTER_LINE,
  REVERSE,
  STOP2_BEFORE_TURN,
  TURN_CLOCKWISE,
  STOP3_AFTER_TURN
};
void enterState(State s);

// =================== Motors (your verified setup) ===================
CytronMD motor1(PWM_DIR, 22, 40);   // Right front
CytronMD motor2(PWM_DIR, 24, 42);   // Right rear  (encoder A2)
CytronMD motor3(PWM_DIR, 26, 44);   // Left  rear  (encoder A3)
CytronMD motor4(PWM_DIR, 28, 46);   // Left  front

// =================== Encoders (optional) ===================
const uint8_t ENC_RIGHT = A2;  // right-rear encoder (motor 2)
const uint8_t ENC_LEFT  = A3;  // left-rear  encoder (motor 3)
volatile long rightTicks = 0, leftTicks = 0;
void isrRight() { rightTicks++; }
void isrLeft()  { leftTicks++;  }

// =================== Line Sensors ===================
#define LFS_L A7
#define LFS_M A5
#define LFS_R A6

// --- Parameters ---
int  threshold        = 1004;      // adjust after printing RAW values
int  forwardSpeed     = 140;       // 0..255
int  reverseSpeed     = 140;       // 0..255
int  turnSpeed        = 150;       // 0..255 (per-side)
unsigned long reverseTimeMs = 500; // 0.5 s reverse
unsigned long settleStopMs  = 150; // small pause between phases
unsigned long turnTimeMs    = 1500; // ~90° (tune this)

// Moving Average
#define WINDOW_SIZE 4
uint16_t bufL[WINDOW_SIZE] = {0}, bufM[WINDOW_SIZE] = {0}, bufR[WINDOW_SIZE] = {0};
uint32_t sumL = 0, sumM = 0, sumR = 0;
uint8_t  wIdx = 0;
bool     filled = false;

// Debounce for line: require consecutive detections
const uint8_t DETECT_COUNT_REQ = 3;
uint8_t detectCount = 0;

// =================== Ultrasonic (two sensors) ===================
// (kept your exact pins & helper)
#define TRIG1 7
#define ECHO1 6
#define TRIG2 4
#define ECHO2 3

float getDistanceCM(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long duration = pulseIn(echoPin, HIGH, 50000); // 50 ms timeout
  float distance = duration * 0.0343f / 2.0f;    // cm
  return distance; // returns 0 if timeout
}

const float OBSTACLE_THRESHOLD_CM = 20.0f;
// Simple debounce for obstacle detection
const uint8_t OB_DETECT_COUNT_REQ = 2;
uint8_t obDetectCount = 0;

// =================== FSM state vars ===================
State state = FORWARD;
unsigned long stateStart = 0;

// ---------------- Helpers ----------------
inline uint16_t updateAvg(uint16_t *buf, uint32_t &sum, uint16_t newVal) {
  uint16_t old = buf[wIdx];
  sum -= old;
  buf[wIdx] = newVal;
  sum += newVal;
  uint8_t n = filled ? WINDOW_SIZE : (wIdx + 1);
  return (uint16_t)(sum / n);
}

void moveForward(int v) {
  motor1.setSpeed(v);
  motor2.setSpeed(v);
  motor3.setSpeed(v);
  motor4.setSpeed(v);
}
void moveBackward(int v) {
  motor1.setSpeed(-v);
  motor2.setSpeed(-v);
  motor3.setSpeed(-v);
  motor4.setSpeed(-v);
}
void turnCW(int v) { // clockwise: right side backward, left side forward
  motor1.setSpeed(-v);  // Right front backward
  motor2.setSpeed(-v);  // Right rear  backward
  motor3.setSpeed( v);  // Left  rear  forward
  motor4.setSpeed( v);  // Left  front forward
}
void stopCar() {
  motor1.setSpeed(0);
  motor2.setSpeed(0);
  motor3.setSpeed(0);
  motor4.setSpeed(0);
}
void enterState(State s) {
  state = s;
  stateStart = millis();
}

// ---------------- Setup ----------------
void setup() {
  Serial.begin(115200);

  pinMode(ENC_RIGHT, INPUT_PULLUP);
  pinMode(ENC_LEFT,  INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(ENC_RIGHT), isrRight, RISING);
  attachInterrupt(digitalPinToInterrupt(ENC_LEFT),  isrLeft,  RISING);

  // Ultrasonic pins
  pinMode(TRIG1, OUTPUT);
  pinMode(ECHO1, INPUT); // ⚠️ level shift to 3.3V if HC-SR04
  pinMode(TRIG2, OUTPUT);
  pinMode(ECHO2, INPUT); // ⚠️ level shift to 3.3V if HC-SR04

  Serial.println("Forward → detect line OR obstacle ≤20cm → stop → reverse 0.5s → stop → 90° CW turn → stop → repeat");
}

// ---------------- Loop ----------------
void loop() {
  // ===== Line sensors =====
  uint16_t rawL = analogRead(LFS_L);
  uint16_t rawM = analogRead(LFS_M);
  uint16_t rawR = analogRead(LFS_R);

  uint16_t avgL = updateAvg(bufL, sumL, rawL);
  uint16_t avgM = updateAvg(bufM, sumM, rawM);
  uint16_t avgR = updateAvg(bufR, sumR, rawR);

  wIdx++;
  if (wIdx >= WINDOW_SIZE) { wIdx = 0; filled = true; }

  bool lineDetectedNow = (avgL > threshold) || (avgM > threshold) || (avgR > threshold);
  if (lineDetectedNow) {
    if (detectCount < 255) detectCount++;
  } else {
    if (detectCount > 0) detectCount--;
  }
  bool lineDetectedStable = (detectCount >= DETECT_COUNT_REQ);

  // ===== Ultrasonic sensors =====
  static unsigned long lastUS = 0;
  static float dist1 = 0, dist2 = 0;
  if (millis() - lastUS >= 50) {           // ~20 Hz update
    lastUS = millis();
    dist1 = getDistanceCM(TRIG1, ECHO1);
    dist2 = getDistanceCM(TRIG2, ECHO2);
  }

  bool obstacleNow = false;
  // treat 0 as "no reading" (timeout); only consider positive distances
  if ((dist1 > 0 && dist1 <= OBSTACLE_THRESHOLD_CM) ||
      (dist2 > 0 && dist2 <= OBSTACLE_THRESHOLD_CM)) {
    obstacleNow = true;
  }

  if (obstacleNow) {
    if (obDetectCount < 255) obDetectCount++;
  } else {
    if (obDetectCount > 0) obDetectCount--;
  }
  bool obstacleStable = (obDetectCount >= OB_DETECT_COUNT_REQ);

  // --- Debug print every 200 ms ---
  static unsigned long prevPrint = 0;
  if (millis() - prevPrint >= 200) {
    prevPrint = millis();
    Serial.print("RAW LMR: "); Serial.print(rawL); Serial.print(" ");
    Serial.print(rawM); Serial.print(" "); Serial.println(rawR);
    Serial.print("AVG LMR: "); Serial.print(avgL); Serial.print(" ");
    Serial.print(avgM); Serial.print(" "); Serial.println(avgR);
    Serial.print("US cm: d1="); Serial.print(dist1, 1);
    Serial.print(" d2="); Serial.print(dist2, 1);
    Serial.print(" | lineDetCnt="); Serial.print((int)detectCount);
    Serial.print(" | obDetCnt="); Serial.print((int)obDetectCount);
    noInterrupts(); long r=rightTicks, l=leftTicks; interrupts();
    Serial.print(" | Ticks R/L: "); Serial.print(r); Serial.print("/"); Serial.println(l);
  }

  // --- FSM ---
  switch (state) {
    case FORWARD:
      moveForward(forwardSpeed);
      // Trigger the same sequence on either a line OR an obstacle ≤ 20 cm
      if (lineDetectedStable || obstacleStable) {
        stopCar();
        if (obstacleStable) Serial.println("Obstacle ≤20cm → STOP1");
        else                Serial.println("Line detected → STOP1");
        enterState(STOP1_AFTER_LINE);
      }
      break;

    case STOP1_AFTER_LINE:
      stopCar();
      if (millis() - stateStart >= settleStopMs) {
        Serial.println("Reverse 0.5s");
        enterState(REVERSE);
      }
      break;

    case REVERSE:
      moveBackward(reverseSpeed);
      if (millis() - stateStart >= reverseTimeMs) {
        stopCar();
        Serial.println("Reverse done → STOP2");
        enterState(STOP2_BEFORE_TURN);
      }
      break;

    case STOP2_BEFORE_TURN:
      stopCar();
      if (millis() - stateStart >= settleStopMs) {
        Serial.println("Turning CW ~90°");
        noInterrupts(); rightTicks = 0; leftTicks = 0; interrupts();
        enterState(TURN_CLOCKWISE);
      }
      break;

    case TURN_CLOCKWISE:
      turnCW(turnSpeed);
      if (millis() - stateStart >= turnTimeMs) {
        stopCar();
        Serial.println("Turn complete → STOP3");
        enterState(STOP3_AFTER_TURN);
      }
      break;

    case STOP3_AFTER_TURN:
      stopCar();
      if (millis() - stateStart >= settleStopMs) {
        // Reset detection counters so we wait for the next event
        detectCount = 0;
        obDetectCount = 0;
        Serial.println("Repeat cycle → FORWARD");
        enterState(FORWARD);
      }
      break;
  }

  delay(20); // small loop delay for stability
}
